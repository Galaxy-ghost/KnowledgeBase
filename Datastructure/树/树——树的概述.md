## 树的表达方式

集合的元素关系呈现出一对多的情况

### 树的定义

-   树（Tree）是n（n≥0）个节点的有限集合T，它满足两个条件：
    

-   有且仅有一个特定的跟称为根节点
    
-   其余的节点可以分为m（m≥0）个互不相交的有限的集合T1、T2、......、Tm，其中每一个集合又是一棵树，并称为其根的子树
    

![img](https://uploader.shimo.im/f/r2h8a3CoxZM1ALpr.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE2MTc3NDMsImZpbGVHVUlEIjoiTDlrQk13UnBFNWlRR3JxSyIsImlhdCI6MTY4MTYxNzQ0MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4MzU0MjM0M30.I-CyVl9Pu5D-Ia-eFHcO9P6LxF5-n1-UWU6cEjNJgzk)

-   树的定义具有递归性，即“树中还有树”
    

### 树的概念

-   结点：使⽤树结构存储的每一个数据元素都被称为“结点”。例如图中的A就是一个结点。
    
-   根结点：有一个特殊的结点，这个结点没有前驱，我们将这种结点称之为根结点。
    
-   ⽗结点（双亲结点）、子结点和兄弟结点：对于ABCD四个结点来说，A就是BCD的⽗结点，也称之为双亲结点。
    
-   ⽽BCD都是A的子结点，也称之为孩子结点。对于BCD来说，因为他们都有同一个爹，所以它们互相称之为兄弟结点。
    
-   叶子结点：如果一个结点没有任何子结点，那么此结点就称之为叶子结点。
    
-   结点的度：结点拥有的子树的个数，就称之为结点的度。
    
-   树的度：在各个结点当中，度的最⼤值。为树的度。
    
-   树的深度或者⾼度：结点的层次从根结点开始定义起，根为第一层，根的孩子为第二层。依次类推。
    

![img](https://uploader.shimo.im/f/YnQ4WpI1zLFAt3Ht.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE2MTc3NDMsImZpbGVHVUlEIjoiTDlrQk13UnBFNWlRR3JxSyIsImlhdCI6MTY4MTYxNzQ0MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4MzU0MjM0M30.I-CyVl9Pu5D-Ia-eFHcO9P6LxF5-n1-UWU6cEjNJgzk)

### 树的存储结构(普通树)

#### 双亲表示法

双亲表示法采⽤顺序表（也就是数组）存储普通树，其实现的核心思想是：顺序存储各个节点的同时，给各节点附加一个记录其⽗节点位置的变量

根节点没有⽗节点（⽗节点又称为双亲节点），因此根节点记录⽗节点位置的变量通常置为 -1

struct x1{  
  Element data[10];   // 顺序表存储数据  
  int parent[10];     // 存储双亲节点的索引  
}

-   利⽤顺序表存储，表元素由数据和⽗结点构成
    

特点分析：

-   根结点没有双亲，所以位置域设置为-1
    
-   知道一个结点，找他的⽗结点，非常容易，O(1)级
    
-   寻找孩子节点，必须遍历整个表
    

-   ![img](https://uploader.shimo.im/f/QoDIBbKXyU6oY2vT.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE2MTc3NDMsImZpbGVHVUlEIjoiTDlrQk13UnBFNWlRR3JxSyIsImlhdCI6MTY4MTYxNzQ0MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4MzU0MjM0M30.I-CyVl9Pu5D-Ia-eFHcO9P6LxF5-n1-UWU6cEjNJgzk)
    

#### 孩子表示法

> 孩子表示法存储普通树采⽤的是 "顺序表+链表" 的组合结构。

> 其存储过程是：从树的根节点开始，使⽤顺序表依次存储树中各个节点。需要注意，与双亲表示法不同的是，孩子表示法会给各个节点配备一个链表，⽤于存储各节点的孩子节点位于顺序表中的位置。

> 如果节点没有孩子节点（叶子节点），则该节点的链表为空链表。

![img](https://uploader.shimo.im/f/ibY8gcAFIEqSf95M.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE2MTc3NDMsImZpbGVHVUlEIjoiTDlrQk13UnBFNWlRR3JxSyIsImlhdCI6MTY4MTYxNzQ0MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4MzU0MjM0M30.I-CyVl9Pu5D-Ia-eFHcO9P6LxF5-n1-UWU6cEjNJgzk)

-   使⽤孩子表示法存储的树结构，正好和双亲表示法相反，查找孩子结点的效率很⾼，⽽不擅长做查找⽗结点的操作
    

struct indexNode {  
  int childIndex;  
  struct indexNode *next;  
};  
​  
struct tree_node{  
  Element data;  
  struct indexNode *childs;  
  int parent;  
};  
​  
struct tree_node tree[10];  
​

下面是将孩子表示法与双亲表示法结合：

![img](https://uploader.shimo.im/f/NjnaSMTNNRddf8zf.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE2MTc3NDMsImZpbGVHVUlEIjoiTDlrQk13UnBFNWlRR3JxSyIsImlhdCI6MTY4MTYxNzQ0MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4MzU0MjM0M30.I-CyVl9Pu5D-Ia-eFHcO9P6LxF5-n1-UWU6cEjNJgzk)

#### 孩子兄弟表示法

> 所谓孩子兄弟表示法，指的是⽤将整棵树⽤二叉链表存储起来，具体实现方案是：从树的根节点开始，依次存储各个结点的孩子结点和兄弟结点。

> 在二叉链表中，各个结点包含三部分内容：

> ![img](https://uploader.shimo.im/f/tVx7N4kGANPAIKNM.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE2MTc3NDMsImZpbGVHVUlEIjoiTDlrQk13UnBFNWlRR3JxSyIsImlhdCI6MTY4MTYxNzQ0MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4MzU0MjM0M30.I-CyVl9Pu5D-Ia-eFHcO9P6LxF5-n1-UWU6cEjNJgzk)

**示例图**

![img](https://uploader.shimo.im/f/qewd7O6vG1ams2Wf.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2ODE2MTc3NDMsImZpbGVHVUlEIjoiTDlrQk13UnBFNWlRR3JxSyIsImlhdCI6MTY4MTYxNzQ0MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4MzU0MjM0M30.I-CyVl9Pu5D-Ia-eFHcO9P6LxF5-n1-UWU6cEjNJgzk)